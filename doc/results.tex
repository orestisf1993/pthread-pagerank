\chapter{Αποτελέσματα}
Σε αυτό το κομμάτι παρουσιάζονται όλα τα πειραματικά αποτελέσματα.
\section{Έλεγχος ορθότητας}
Εδώ φαίνονται τα τελικά αποτελέσματα (rankings) που προέκυψαν από την εφαρμογή του αλγορίθμου σε 2 διαφορετικούς γράφους.

Το πρώτο προέκυψε με την χρήση της συνάρτηση surfer.m στη σελίδα \href{http://stackoverflow.com/}{stackoverflow.com}.
O γράφος που δημιουργήθηκε από το stackoveflow φαίνεται στο
\hyperref[fig:stackGraph]{\figurename{} \ref{fig:stackGraph}}
\begin{figure}[h]
	\centerline{\includegraphics[width=0.6\textwidth]{plots/stackGraph.pdf}}
	\caption{Γράφος συνδέσεων stackoverflow.}
	\label{fig:stackGraph}
\end{figure}
 
Τα αποτελέσματα για τη MATLAB και τη C φαίνονται στο \hyperref[fig:stackres]{\figurename{} \ref{fig:stackres}}
\begin{figure}[h]
	\centerline{\includegraphics[width=0.85\textwidth]{plots/stackres.pdf}}
	\caption{Αποτελέσματα για stackoverflow}
	\label{fig:stackres}
\end{figure}
 
Βλέπουμε ότι τα αποτελέσματα μεταξύ των 2 υλοποιήσεων ταυτίζονται σε πολύ μεγάλο βαθμό.
Επίσης, σε σχέση με το
\hyperref[fig:stackGraph]{\figurename{} \ref{fig:stackGraph}}
μπορούμε να επιβεβαιώσουμε  εποπτικά την ορθότητα των αποτελέσματά μας
παρατηρώντας ότι οι μεγαλύτερες πιθανότητες εμφανίζονται στους κόμβους 40 και 90
οι οποίοι  σύμφωνα με το 
\hyperref[fig:stackGraph]{\figurename{} \ref{fig:stackGraph}}
έχουν τα περισσότερα links προς αυτούς (κάθετος άξονας).
Επίσης, ο αριθμός των επαναλήψεων που χρειάστηκε για να συγκλίνει το $P$ ήταν 40.
Ο κάνονας που θέσαμε ήταν να μην υπάρχει μεταβολή μεγαλύτερη του $10^{-6}$ σε σχέση με το προηγούμενο $P$ για οποιονδήποτε κόμβο.
Η μεγάλη συνδεσιμότητα του γράφου θα μπορούσε ίσως να είναι η αιτία 
(\href{https://en.wikipedia.org/wiki/Clustering_coefficient#Global_clustering_coefficient}{average clustering coefficient} 0.518)
για  το σχετικά μεγάλο αυτό νούμερο καθώς οι μεταβολές θα ήταν πολύ πυκνές και συχνά αλληλοαναιρούμενες.

\newpage

Για το δεύτερο αποτέλεσμα χρησιμοποιήθηκε γράφος όπου προέρχεται από αυτό το
\href{http://snap.stanford.edu/data/soc-Slashdot0811.html}{link} 
και περιέχει ένα δίκτυο από το
\href{http://slashdot.org/}{http://slashdot.org/}
και φαίνεται στο
\hyperref[fig:slashGraph]{\figurename{} \ref{fig:slashGraph}}
\begin{figure}[h!]
	\centering
	\subfloat[]{\includegraphics[width=0.5\textwidth]{plots/slash.png}}
	\subfloat[]{\includegraphics[width=0.5\textwidth]{plots/slashGraphDet.pdf}}
	\caption{O γράφος συνδέσεων slashdot με μία λεπτομέρεια στα δεξιά}
	\label{fig:slashGraph}
\end{figure}

Ο γράφος δεν είναι τόσο πυκνός όσο φαίνεται.
Από μία λεπτομέρεια στην πάνω αριστερά γωνία διαφαίνεται ότι είναι αρκετά αραιός,
έχει
\href{https://en.wikipedia.org/wiki/Clustering_coefficient#Global_clustering_coefficient}{average clustering coefficient} 0.055499.

Το ranking που προκύπτει για αυτό το δίκτυο φαίνεται στο
\hyperref[fig:slackres]{\figurename{} \ref{fig:slackres}}.
\begin{figure}[h!t]
	\centering
	\includegraphics[width=0.9\textwidth]{plots/slashdot.png}
	\caption{Αποτελέσματα για slashdot}
	\label{fig:slackres}
\end{figure}
Επιβεβαιώνουμε την ορθότητα των αποτελεσμάτων μας με το ίδιο σκεπτικό όπως στην προηγούμενη περίπτωση.
Βλέπουμε λοιπόν ότι η παράλληλη υλοποίηση δουλεύει σωστά και για πολύ μεγαλύτερο αριθμό κόμβων.
Τέλος, πρέπει να σημειώσουμε ότι τα βήματα που χρειάστηκαν για την σύγκλιση ήταν μόλις 19.
Θα περίμενε κανείς ότι ένας μεγαλύτερος γράφος με τόσο μεγάλη ασυμμετρία θα χρειαζόταν περισσότερα βήματα για να συγκλίνει σε σχέση με το γράφο του stackoveflow.
Μία πιθανή  εξήγηση ίσως ήταν πως ο γράφος είναι  πολύ πιο αραιός σε σχέση με τον stackoverflow και συγκλίνει  στο τελικό διάνυσμα πολύ πιο γρήγορα.
\clearpage
\section{Χρόνος εκτέλεσης}
Οι γράφοι που χρησιμοποιήθηκαν βρίσκονται στα ακόλουθα link:
\begin{enumerate} 
	\item \href{https://snap.stanford.edu/data/wiki-Vote.html}{Wiki-Vote}.
	\item \href{https://snap.stanford.edu/data/email-EuAll.html}{email-EuAll}.
	\item \href{https://snap.stanford.edu/data/web-BerkStan.html}{web-BerkStan}.
	\item \href{https://snap.stanford.edu/data/web-NotreDame.html}{web-NotreDame}.
	\item \href{https://snap.stanford.edu/data/web-Google.html}{web-Google}.
	\item \href{https://snap.stanford.edu/data/soc-pokec.html}{soc-pokec}.
\end{enumerate}
%TODO: link dropbox με τα παντα

Πληροφορίες επεξεργαστή στον οποίο έγινε η εκτέλεση:
\begin{lstlisting}[style=Bash]
$ lscpu
Architecture:          x86_64
CPU op-mode(s):        32-bit, 64-bit
Byte Order:            Little Endian
CPU(s):                6
On-line CPU(s) list:   0-5
Thread(s) per core:    2
Core(s) per socket:    3
Socket(s):             1
NUMA node(s):          1
Vendor ID:             AuthenticAMD
CPU family:            21
Model:                 2
Model name:            AMD FX(tm)-6300 Six-Core Processor
Stepping:              0
CPU MHz:               4113.398
BogoMIPS:              8226.79
Virtualization:        AMD-V
L1d cache:             16K
L1i cache:             64K
L2 cache:              2048K
L3 cache:              8192K
NUMA node0 CPU(s):     0-5
\end{lstlisting}

\noindent
\begin{minipage}{\textwidth}
	\centering
	\includegraphics[width=0.99\textwidth]{plots/absolute_time.pdf}
	\captionof{figure}{Χρόνος εκτέλεσης σε σχέση με αριθμό thread και αριθμό κόμβων.}
	\label{fig:absolute_time}
Παρατηρούμε αναμενόμενα στο \hyperref[fig:absolute_time]{\figurename{} \ref{fig:absolute_time}} ότι όσο αυξάνεται το μέγεθος του γράφου μας τόσο αυξάνεται και ο χρόνος εκτέλεσης(πολυπλοκότητα Ο(kn)) .Ο αλγόριθμός μας δουλεύει και για γράφους μεγαλύτερους του ενός εκατομμυρίου .
Τέλος βλέπουμε πως τα περισσότερα thread έχουν όλο και καλύτερες επιδόσεις σε σχέση με τα λιγότερα  όσο αυξάνεται το μέγεθος του γράφου.
Σε πολύ μικρούς γράφους είναι δυνατόν τα περισσότερα thread να έχουν χειρότερη επίδοση
\end{minipage}

\noindent
\begin{minipage}{\textwidth}
	\centering
	\includegraphics[height=0.99\textheight]{plots/relative_time.pdf}
	\captionof{figure}{Επιτάχυνση σε σχέση με 1 thread.}
	\label{fig:relative_time}
	Στο  \hyperref[fig:relative_time]{\figurename{} \ref{fig:relative_time}} βλέπουμε την σχετική βελτίωση του χρόνου
σε σχέση με τον 1 thread. Η σχετική βελτίωση που θα πετύχουμε εξαρτάται όχι μόνο από το μέγεθος του γράφου αλλά και από άλλα χαρακτηριστικά του όπως η συνδεσιμότητα του κ.α. Γεγονός που δικαιολογεί την μικρότερη σχετική βελτίωση στο γράφο του 1.6 εκατομμυρίου σε σχέση με τον 910 χιλιάδων (κόμβων). Όμως αν τα άλλα χαρακτηριστικά ήταν σταθερά η σχετική βελτίωση που θα υπήρχε
θα ήταν γνησίως αύξουσα συνάρτηση του αριθμού των κόμβων. Τέλος η χρήση του smart split δεν μας έδωσε ξεκάθαρα καλύτερα αποτελέσματα για αυτό και δεν υπάρχει γράφημα που να δείχνει τη χρήση του.
\end{minipage}]

\noindent
\begin{minipage}{\textwidth}
	\section{Σύγκλιση γενεών}
	\centering
	\includegraphics[angle=0,height=0.95\textheight]{plots/generation.pdf}
	\captionof{figure}{Αριθμός επαναλήψεων για σύγκλιση σε σχέση με αριθμό κόμβων.}
	\label{fig:generation}
           Στο  \hyperref[fig:generation]{\figurename{} \ref{fig:generation}}  βλέπουμε τον αριθμό των γενεών που χρειάζονται για να συγκλίνει ο αλγόριθμος ( η απόλυτη διαφορά $|P^{t+1} - P^t|$ να μην έχει ούτε ένα στοιχείο πάνω από $10^{-6}$ ).Θα μπορούσε κανείς να υποθέσει ότι σε τυχαίους πραγματικούς  γράφους (συμβολίζουν ένα πραγματικό δίκτυο) όπως αυτούς που έχουμε, συνήθως μεγαλύτερος γράφος σημαίνει και λιγότερες επαναλήψεις μέχρι την σύγκλιση. Όμως τα δεδομένα είναι πολύ λίγα για να βγάλουμε με σιγουριά τέτοιο συμπέρασμα.Η απάντηση λογικά περιέχει και πολλά άλλα χαρακτηριστικά του γράφου.
\end{minipage}
